
# &#1057;&#1086;&#1076;&#1077;&#1088;&#1078;&#1072;&#1085;&#1080;&#1077;

1.  [Введение](#org54a9668)
2.  [Особенности **Ocaml**](#org4e4bf9d)
3.  [Загрузка и установка](#orgbf36c71)
4.  [Использование **REPL**](#org7179653)
5.  [Встроенные типы данных](#org28400db)
    1.  [Кортежи](#orgdce690e)
    2.  [Списки](#org096fe11)
    3.  [Массивы](#org5f9cc17)
6.  [Конструкция **let**](#orgaa01832)
    1.  [Пример с проверкой числа на простоту](#org972a428)
7.  [Работа с source-файлами](#org596469f)
8.  [Список источников](#orgb2f00ac)
    1.  [Ссылки](#orgcddf497)
    2.  [Книги](#org5b55f0b)



<a id="org54a9668"></a>

# Введение

<span class="underline">Цель данного пособия</span> - познакомить с основами **OCaml**, который относится к разряду функциональных (аппликативных) языков программирования. 

У функциональных языков, ведущих свою "родословную" от Лиспа, сложная и интересная судьба. Эти языки, любимые в университетах, научных институтах и центрах, почти незнакомы широким массам разработчиков.

Не будучи промышленными языками программирования, функциональные языки, тем не менее, являются носителями множества интересных концепций и возможностей, с которыми необходимо познакомиться любому профессионалу в области ИТ. В разные периоды времени, когда традиционные императивные языки выходят из моды, заменяются на более современные, функциональные языки демонстрируют удивительную актуальность в любые времена. Можно утверждать, что они намного опередили свое время, а может быть именно их время ещё не пришло.

**OCaml** достаточно широко используется на Западе для обучения языкам программирования, курсы по нему можно найти во многих университетах мира. На странице <https://ocaml.org/learn/teaching-ocaml.html> приведен внушительный список университетских курсов, изучающих **OCaml**.

Приходится выразить сожаление, что **OCaml** в России почти неизвестен и практически нет книг и пособий, посвящённых ему, за исключением перевода документации и книг&#x2026;


<a id="org4e4bf9d"></a>

# Особенности **Ocaml**

-   Язык является *мультипарадигмальным*, то есть поддерживает несколько парадигм программирования. Среди них:
    -   функциональная
    -   императивная
    -   объектно-ориентированная.
-   Язык обладает высокой степенью *выразительности*, облегчающей его освоение и использование.
-   Пакет разработчика предоставляет возможность как *компиляции* кода программы в бай-код или в машинный код, а также работу с программой в режиме *интерпретатора*.
-   Управление памятью в программах полностью *автоматическое*.
-   Ocaml обеспечивает *статическую* и *строгую* типизацию, что обнаруживает ошибки ещё на этапе компиляции.


<a id="orgbf36c71"></a>

# Загрузка и установка

Основной ресурс **OCaml** расположен по адресу <https://ocaml.org>, там же можно найти ссылки на установочные пакеты для большого числа операционных систем. После загрузки и развёртывания пакета разработчика (можно произвести установку на обычный флеш-накопитель и использовать как portable-приложение) пользователю доступны следующие программы:

-   `ocaml` - интерпретатор;
-   `ocamlc` - компилятор в байт-код;
-   `ocamlopt` - компилятор в машинный (native) код;

Представляет интерес использование редактора **MS Visual Studio Code**, далее сокращенно **vscode** для разработки. Необходимо установить расширение редактора <https://github.com/hackwaly/vscode-ocaml> или <https://github.com/reasonml-editor/vscode-reasonml> для комфортной работы. В качестве интерпретатора можно использовать `ocaml` или (что еще лучше)- `utop`. 

Менеджер пакетов **OCaml** называется `opam`. С помощью этой программы устанавливается большинство библиотечных пакетов. 

Более подробная информация об установки и настройке приведена на странице <https://ocaml.org/docs/install.html>


<a id="org7179653"></a>

# Использование **REPL**

Для перехода в режим интерпретатора нужна запустить программу `ocaml`. Появится приглашение командной строки (#) и система переходит в режим **REPL**.

    OCaml version 4.07.0
    
    # 

**Read Eval Print Loop** является одним из самых популярных режимов работы с программами на **OCaml**. Вы просто набираете в интерпретаторе выражения, а потом видите результат их исполнения.

Рассмотрим примеры использования **OCaml** в качестве калькулятора:

    # 3 + 5;;

Результат выполнения:

<div class="verbatim">
-   : int = 8

</div>

**OCaml** является строготипизированным языком, так что появление **int** в ответе не должно удивлять. Тип результата выражения должен совпадать с типами операндов. Попробуйте смешать в одном выражение целочисленную и вещественную константы и вы немедленно получите сообщение об ошибке:

    # 3 + 5.7;;
    Characters 2-5:
      3+5.7;;
        ^^^
    Error: This  expression has type float 
    but an expression was expected of type
    int

На первый взгляд, такое поведение интерпретатора может показаться странным, но не будем забывать, что именно с неявным преобразованием типов в программах начинают появляться трудноуловимые ошибки.

Знаки операций для целых и вещественных чисел отличаются: `+` и `+.`

    # 1.7 +. 7.1;;
    - : float = 8.7999999999999989

Для преобразования значений из одного типа в другой существуют специальные функции **int\_of\_float** и **float\_of\_int**:

    # int_of_float 1.7 + 4;;
    - : int = 5
    # 1.7 +. float_of_int 4;;
    - : float = 5.7

Для выхода из интерпретатора в ОС нужно выполнить команду `exit 0;;`


<a id="org28400db"></a>

# Встроенные типы данных

В качестве основных типов используются:

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Название</th>
<th scope="col" class="org-left">Обозначение</th>
<th scope="col" class="org-left">Пример</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left">Целый</td>
<td class="org-left">int</td>
<td class="org-left">8</td>
</tr>


<tr>
<td class="org-left">Вещественный</td>
<td class="org-left">float</td>
<td class="org-left">3.1</td>
</tr>


<tr>
<td class="org-left">Логический</td>
<td class="org-left">bool</td>
<td class="org-left">true</td>
</tr>


<tr>
<td class="org-left">Строковый</td>
<td class="org-left">string</td>
<td class="org-left">"Hello"</td>
</tr>


<tr>
<td class="org-left">Символьный</td>
<td class="org-left">char</td>
<td class="org-left">'a'</td>
</tr>


<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

Дополнительно к типам (множественным) относят:

-   кортежи
-   списки
-   массивы

Пример действий над строками (конкатенации):

    # "Hello " ^ "world!";;
    - : string = "Hello world!"

Пример действий с символьным типом:

    # int_of_char('A');;
    - : int = 65

Для работы с логическим типом имеются логические операции:

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Название</th>
<th scope="col" class="org-left">Обозначение</th>
<th scope="col" class="org-left">Пример</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left">Отрицание</td>
<td class="org-left">not</td>
<td class="org-left">not true</td>
</tr>


<tr>
<td class="org-left">Конъюнкция</td>
<td class="org-left">&&</td>
<td class="org-left">true && false</td>
</tr>


<tr>
<td class="org-left">Дизъюнкция</td>
<td class="org-left">ll</td>
<td class="org-left">true ll false</td>
</tr>
</tbody>
</table>

Для сравнения значений между собой используют такие операции:

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Название</th>
<th scope="col" class="org-left">Обозначение</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left">Структурное равенство</td>
<td class="org-left">=</td>
</tr>


<tr>
<td class="org-left">Физическое равенство</td>
<td class="org-left">==</td>
</tr>


<tr>
<td class="org-left">Отрицание =</td>
<td class="org-left"><></td>
</tr>


<tr>
<td class="org-left">Отрицание ==</td>
<td class="org-left">!=</td>
</tr>


<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

Чем отличаются структурное и физическое равенства?

**Структурное** равенство позволяет сравнить значение полей структуры (при множественных типах), в то время как **физическое** сравнивает адреса в памяти. Следует помнить, что вещественные числа и строки относятся к *структурным* типам.


<a id="orgdce690e"></a>

## Кортежи

**Кортеж** представляет собой набор величин разных типов, например:

    # (1,4.5,"OK");;
    - : int * float * string = (1, 4.5, "OK")

Здесь имеется три величины разных типов, которые **OCaml** определил как `int*float*string`

Для кортежей длины 2 (пар) можно использовать функции **fst** и **snd**:

    # fst ("hello","world");;
    - : string = "hello"
    # snd ("hello","world");; 
    - : string = "world"


<a id="org096fe11"></a>

## Списки

**Списком** называется набор данных одного типа. 

    # [1;2;3];;
    - : int list = [1; 2; 3]

Первой важной операцией для работы со списком является **::**, которая позволяет добавить в список очередной элемент, или построить список из нескольких элементов:

    # 0::[1;2;3;4];;
    - : int list = [0; 1; 2; 3; 4]
    # 1::2::3::4::5::[];;
    - : int list = [1; 2; 3; 4; 5]

Вторая операция **@** объединяет несколько списков в один:

    # [1;2;3]@[4;5;6];;
    - : int list = [1; 2; 3; 4; 5; 6]


<a id="org5f9cc17"></a>

## Массивы

**Массивом** называется разновидность списка фиксированного размера

    # [|1;2;3|];;
    - : int array = [|1; 2; 3|]

Для массивов определён специальный синтаксис, позволяющий обращаться по индексу к его элементам:

    # [|1;2;3|].(0);;
    - : int = 1

Индексация, как и во многих других языках, производится, начиная с нуля.

Следует заметить, что строки в **OCaml** тоже представляют собой разновидность массивов (как в Си), так что допускается ображение к отдельным символам по индексам:

    # "hello".[0];;
    - : char = 'h'


<a id="orgaa01832"></a>

# Конструкция **let**

С помощью конструкции **let** можно задавать имена различным экземплярам данных, а также объявлять функции.

Создадим именованную константу:

    # let pi=3.14;;
    val pi : float = 3.14

В дальнейшем можно использовать имена для построения других выражений:

    # let pi2=2. *. pi;;
    val pi2 : float = 6.28

Приведённые примеры использования **let** задают **глобальные объявления**, которые будут действовать на всём протяжении программы.

Одной из форм использования **let** является группировка глобальных объявлений:

    # let a=1 and b=2 and c=3;;
    val a : int = 1
    val b : int = 2
    val c : int = 3

**Локальное объявление** создаёт связь между именем и значеним в определённой области кода:

    # let a=2 in a*a;;
    - : int = 4

Аналогично можно использовать группировку при локальных обхявлениях:

    # let a=2 and b=3 in a*b;;
    - : int = 6


<a id="org972a428"></a>

## Пример с проверкой числа на простоту

Рассмотрим пример функции, которая получает целое число на вход и проверяет, является ли переданное число простым (не имеет делителей, кроме себя и 1).

Первая реализация:

    # let is_prime n =
        let n = abs n in
        let rec is_not_divisor d =
          d * d > n || (n mod d <> 0 && is_not_divisor (d+1)) in
        n <> 1 && is_not_divisor 2;;


<a id="org596469f"></a>

# Работа с source-файлами

Режим **REPL** - не единственный режим работы **OCaml**. Можно подготовить файл с исходным кодом и загрузить его в интерпретатор, а можно скомпилировать, причём компиляция осуществляется либо в бай-код, либо в машинный код.

Рассмотрим, как можно загрузить файл в интерпретатор и выполнить его.

    (* Содержимое hello.ml *)
    Printf.printf "Hello, world!\n" 

Далее, мы загружаем подготовленный файл из интерпретатора:

    # #use "путь/hello.ml";;
    Hello, world!
    - : unit = ()

При использовании команды **use** нужно указать либо абсолютный либо относительный путь к файлу с исходным кодом.


<a id="orgb2f00ac"></a>

# Список источников


<a id="orgcddf497"></a>

## Ссылки

-   Главный сайт:  <https://ocaml.org>.
-   PLEAC: <http://pleac.sourceforge.net/pleac_ocaml/>
-   Try OCaml: <http://try.ocamlpro.com/>
-   Real world OCaml book: <http://dev.realworldocaml.org>
-   Awesome OCaml: <https://github.com/ocaml-community/awesome-ocaml>


<a id="org5b55f0b"></a>

## Книги

-   *Hickey J.* Introduction to Objective Caml, 2008.
-   *Harrop J.* OCaml for scientists, 2005.
-   *Chailloux E., Manoury P., Pagano B.* Developing applications with Objective Caml, O'Reilly, 2000.
-   *Chailloux E., Manoury P., Pagano B.* Разработка программ с помощью Objective Caml, (русский перевод), 2007.
-   *Smith J.* Practical OCaml, APress, 2006.
-   *Downey A., Monje N.* Think OCaml, Green Tea Press, 2008.
-   *Whitington J.* OCaml from the Very Beginning, Coherent press. Cambridge, 2013.
-   *Whitington J.* More OCaml: Algorithms, Methods, and Diversions, Coherent press. Cambridge, 2014.
-   *Leroy X., Remy D.* Unix system programming in OCaml, 2013.
-   *Minsky Y., Madhavapeddy A., Hickey J.* Real world OCaml, O'Reilly, 2013.
-   *Didier Rémy* Using, Understanding, and Unraveling OCaml, 2001.

